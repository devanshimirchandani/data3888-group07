```{r include=FALSE}
library(GEOquery) 
library(R.utils)
library(reshape2)
library(ggplot2)
library(limma)
library(dplyr)
library(tidyr)
gse_15852 <- getGEO("GSE15852")
```

```{r echo=FALSE}
gseset <- gse_15852[[1]]

f = fData(gseset)

p = pData(gseset)

M <- exprs(gseset)

M_log2 <- log2(M)

dim(gseset)
```
# Try and figure out PCA separation
```{r}
library(Biobase)
library(ggplot2)

gseset$Outcome <- ifelse(grepl("Cancer", gseset$title), "Cancer", "Normal")
table(gseset$Outcome )

pca <- prcomp(t(M_log2), scale. = TRUE)

pca_df <- data.frame(
  PC1 = pca$x[, 1],
  PC2 = pca$x[, 2],
  Outcome = gseset$Outcome
)

ggplot(pca_df, aes(x = PC1, y = PC2, color = Outcome)) +
  geom_point(size = 3) +
  theme_bw() +
  labs(title = "PCA Plot", x = "PCA 1", y = "PCA 2")
```
### PC1 and PC2 respectively explained approximately 35.3% and 8.0% of the overall variation. The samples presented two distinct clusters on the left and right along the PC1 axis, but within each cluster, the cancer (red dots) and normal (blue dots) samples were not strictly separated
```{r}
pd     <- pData(gseset)
col_info <- data.frame(
  var       = colnames(pd),
  class     = sapply(pd, class),
  n_unique  = sapply(pd, function(x) length(unique(x))),
  n_missing = sapply(pd, function(x) sum(is.na(x))),
  stringsAsFactors = FALSE
)

keep_vars <- col_info$var[
  col_info$n_unique > 1 & 
  col_info$n_unique < 86
]

print(keep_vars)
```
```{r}
# source_name_ch1 and Outcome are identical, both indicating “Cancer” vs. “Normal.”
# characteristics_ch1.1 and histopathological exam:ch1 are the same.
# characteristics_ch1.2 and grade:ch1 are the same.
# characteristics_ch1.3 and age in years:ch1 are the same.
# characteristics_ch1.4 and race:ch1 are the same.
# gradeFactor and Outcome are columns we added ourselves.
# description and source_name_ch1 are identical, both indicating “breast tumor” vs. “normal breast tissue.”

library(dplyr)

rep_vars <- c(
  "Outcome",
  "histopathological exam:ch1",
  "gradeFactor",
  "age in years:ch1",   
  "race:ch1"
)

meta <- pData(gseset)[, rep_vars, drop = FALSE] 
meta[] <- lapply(meta, as.factor)  

meta$PC1 <- pca$x[,1]

res <- lapply(names(meta)[names(meta)!="PC1"], function(v) {
  grp <- meta[[v]]
  y   <- meta$PC1
  nlev <- nlevels(grp)
  
  if (nlev == 2) {
    wt <- wilcox.test(y ~ grp)
    data.frame(var=v, test="Wilcoxon", p.value=wt$p.value)
  } else {
    kt <- kruskal.test(y ~ grp)
    data.frame(var=v, test="Kruskal–Wallis",p.value=kt$p.value)
  }
}) %>% bind_rows() %>% arrange(p.value)

print(res)

```

```{r}
library(limma)
pd    <- pData(gseset)
age   <- as.numeric(pd$`age in years:ch1`)

covs <- model.matrix(~ age, data=pd)[,-1]

M_corr <- removeBatchEffect(M_log2, covariates=covs)

```

```{r}
pca2 <- prcomp(t(M_corr), center=TRUE, scale.=TRUE)
var2 <- pca2$sdev^2/sum(pca2$sdev^2)
pct1 <- round(var2[1]*100,1); pct2 <- round(var2[2]*100,1)

df2 <- data.frame(PC1=pca2$x[,1], PC2=pca2$x[,2],
                  Outcome=ifelse(grepl("Cancer", gseset$title),"Cancer","Normal"))
library(ggplot2)
ggplot(df2, aes(PC1,PC2,color=Outcome)) +
  geom_point() +
  theme_bw() +
  labs(x=paste0("PC1 (",pct1,"%)"),
       y=paste0("PC2 (",pct2,"%)"),
       title="PCA after covariate correction")

```
# First identify the significant genes and then make the pca plot
```{r}
# Based on limma, the differentially expressed genes of "Cancer vs Normal" were screened out, and PCA was performed on the expression matrices of these genes
# sig_genes are all in the comparison of "Cancer vs Normal"
library(limma)
library(ggplot2)

pd <- pData(gseset)
pd$Outcome <- factor(ifelse(grepl("Cancer", pd$title), "Cancer","Normal"),
                     levels=c("Normal","Cancer"))


design <- model.matrix(~ 0 + Outcome, data=pd)
colnames(design) <- c("Normal","Cancer")
fit <- lmFit(M_log2, design)
cont <- makeContrasts(Cancer - Normal, levels=design)
fit2 <- contrasts.fit(fit, cont)
fit2 <- eBayes(fit2)

tt <- topTable(fit2, number=Inf, adjust.method="BH", p.value=0.05)
sig_genes <- rownames(tt)

pca_sig <- prcomp(t(M_log2[sig_genes, , drop=FALSE]), 
                  center=TRUE, scale.=TRUE)
var_exp <- pca_sig$sdev^2 / sum(pca_sig$sdev^2)
pct1 <- round(var_exp[1]*100,1)
pct2 <- round(var_exp[2]*100,1)

pca_df2 <- data.frame(
  PC1     = pca_sig$x[,1],
  PC2     = pca_sig$x[,2],
  Outcome = pd$Outcome
)

ggplot(pca_df2, aes(PC1, PC2, color=Outcome)) +
  geom_point(size=3) +
  theme_bw() +
  labs(
    title = "PCA on Genes Selected for Cancer vs Normal",
    x = paste0("PC1 (", pct1, "%)"),
    y = paste0("PC2 (", pct2, "%)")
  )

```

```{r}
library(limma)
library(e1071)    # svm
library(caret)    # createFolds

set.seed(3888)

X <- t(M_log2)          # Dimension: Sample rows, gene columns
y <- pd$Outcome         # Two types of factors: Normal/Cancer

# five folds
outer_folds <- createFolds(y, k = 5, returnTrain = FALSE)

all_preds <- vector("list", length(outer_folds))
all_truth <- vector("list", length(outer_folds))

for(i in seq_along(outer_folds)) {
  test_idx  <- outer_folds[[i]]
  train_idx <- setdiff(seq_along(y), test_idx)
  
  # -- The first step: Use limma for differential gene screening on the training set --
  design_tr <- model.matrix(~ 0 + y[train_idx])
  colnames(design_tr) <- levels(y)
  fit       <- lmFit(t(X[train_idx, ]), design_tr)
  cont      <- makeContrasts(Cancer - Normal, levels = design_tr)
  fit2      <- contrasts.fit(fit, cont)
  fit2      <- eBayes(fit2)
  topTab    <- topTable(fit2, adjust.method = "BH", p.value = 0.05, number = Inf)
  sel_genes <- rownames(topTab)
  
  # Step 2: Train the SVM on the training set using the selected genes
  svm_mod <- svm(x         = X[train_idx, sel_genes],
                 y         = y[train_idx],
                 kernel    = "radial",      
                 probability = TRUE)
  
  # -- Step 3: Evaluate on the test set --
  preds      <- predict(svm_mod, X[test_idx, sel_genes])
  all_preds[[i]] <- preds
  all_truth[[i]] <- y[test_idx]
}

pred_vec  <- unlist(all_preds)
truth_vec <- unlist(all_truth)
confusionMatrix(pred_vec, truth_vec)

```



