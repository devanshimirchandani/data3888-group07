---
output:
  html_document:
    code_folding: hide
    toc: true
    toc_depth: 2
    toc_float: true
    theme: readable
---
```{r include=FALSE}
library(GEOquery) 
library(R.utils)
library(reshape2)
library(ggplot2)
library(limma)
library(dplyr)
library(tidyr)

gse <- getGEO("GSE10810")
gse10810 <- gse[[1]]
```
# Data Processing
## Check for NA values, The size of the dataset
```{r echo=FALSE}

f = fData(gse10810)
dim(gse10810)
```
## extract and standardize grade into correct names
```{r}
library(Biobase)

standardize_grade <- function(grades, pattern, replacements, remove_na = TRUE) {
  grades <- tolower(grades)
  for (i in seq_along(pattern)) {
    grades <- gsub(pattern[i], replacements[i], grades)
  }
  grades <- gsub(".*(\\b[0-3]\\b).*", "\\1", grades)  
  grades[!grades %in% c("0", "1", "2", "3")] <- NA
  if (remove_na) grades <- as.numeric(grades)
  grade_names <- c("0" = "Normal", "1" = "Grade1", "2" = "Grade2", "3" = "Grade3")
  grades <- grade_names[as.character(grades)]
  return(grades)
}

pdata10810 <- pData(gse10810)
grades10810 <- pdata10810$characteristics_ch1.3
# Patterns to handle: "grade: 0", "grade: i", "grade: ii", "grade: iii"
pdata10810$grade <- standardize_grade(
  grades10810,
  c("grade: 0", "grade: i\\b", "grade: ii\\b", "grade: iii\\b"),
  c("0", "1", "2", "3")
)

keep <- !is.na(pdata10810$grade)
pdata10810 <- pdata10810[keep, ]

expr10810 <- exprs(gse10810)[, keep]

stopifnot(all(rownames(pdata10810) == colnames(expr10810)))
table(pdata10810$grade)
```

## Removing lowly expressed genes
```{r}
library(edgeR)
library(ggplot2)
library(reshape2)
library(magrittr)
library(cowplot)
library(dplyr)

if (!"sample" %in% colnames(pdata10810)) {
  pdata10810$sample <- rownames(pdata10810)
}

dge <- DGEList(counts = expr10810)

min_group_size <- min(table(pdata10810$grade))

keepTheseGenes <- rowSums(cpm(dge) > 1) >= min_group_size

beforeFiltering_plot <- dge %>% 
  cpm(log = TRUE) %>% 
  melt() %>% 
  filter(is.finite(value)) %>% 
  ggplot(aes(x = value, colour = Var2)) +
    geom_density() +
    guides(colour = FALSE) +
    ggtitle("A. Before filtering", 
            subtitle = paste0(nrow(dge), " genes")) +
    labs(x = "logCPM", y = "Density")

afterFiltering_plot <- dge %>% 
  cpm(log = TRUE) %>%
  magrittr::extract(keepTheseGenes, , drop = FALSE) %>%
  melt() %>% 
  filter(is.finite(value)) %>% 
  ggplot(aes(x = value, colour = Var2)) +
    geom_density() +
    guides(colour = FALSE) +
    ggtitle("B. After filtering", 
            subtitle = paste0(sum(keepTheseGenes), " genes")) +
    labs(x = "logCPM", y = "Density")

cowplot::plot_grid(beforeFiltering_plot, afterFiltering_plot)

expr10810_filtered <- expr10810[keepTheseGenes, ]


pdata10810_filtered <- pdata10810 %>% 
  filter(sample %in% colnames(expr10810_filtered))

expr10810_filtered <- expr10810_filtered[, pdata10810_filtered$sample]

stopifnot(all(colnames(expr10810_filtered) == pdata10810_filtered$sample))

# - expr10810_filtered：A matrix containing only highly expressed genes
# - pdata10810_filtered：pData that only contains these samples

```

## PCA Plot(use filtering genes)
```{r}
samples_to_keep <- intersect(
  colnames(expr10810_filtered),
  rownames(pdata10810_filtered)
)

expr_mat <- expr10810_filtered[, samples_to_keep]
pdata_sub <- pdata10810_filtered[samples_to_keep, , drop = FALSE]

expr_for_pca <- t(expr_mat)

grade_fac <- factor(
  pdata_sub$grade,
  levels = c("Normal", "Grade1", "Grade2", "Grade3")
)

pca_res <- prcomp(expr_for_pca, center = TRUE, scale. = TRUE)

pca_df <- data.frame(
  PC1   = pca_res$x[, 1],
  PC2   = pca_res$x[, 2],
  Grade = grade_fac
)

library(ggplot2)
ggplot(pca_df, aes(x = PC1, y = PC2, color = Grade)) +
  geom_point(size = 3, alpha = 0.8) +
  stat_ellipse(type = "norm", linetype = 2) +
  theme_bw() +
  labs(
    title = "PCA of Samples by Grade",
    x     = paste0("PC1 (", round(100 * summary(pca_res)$importance[2, 1], 1), "%)"),
    y     = paste0("PC2 (", round(100 * summary(pca_res)$importance[2, 2], 1), "%)")
  ) +
  theme(
    legend.position = "right",
    plot.title     = element_text(hjust = 0.5)
  )


```

## 80/20 Train/Test Split 
```{r echo=FALSE, message=FALSE, warning=FALSE}
library(caret)
library(lattice)

set.seed(123)

metadata_pf <- pdata10810_filtered
expr_pf     <- expr10810_filtered

split_by_grade <- split(metadata_pf, metadata_pf$grade)

train_samples <- unlist(lapply(split_by_grade, function(df) {
  n <- nrow(df)
  size <- if (n >= 2) floor(0.8 * n) else 1
  sample(df$sample, size = size)
}))

test_samples <- setdiff(metadata_pf$sample, train_samples)

expr_train <- expr_pf[, train_samples]
expr_test  <- expr_pf[, test_samples]

metadata_train <- metadata_pf[match(train_samples, metadata_pf$sample), ]
metadata_test  <- metadata_pf[match(test_samples,  metadata_pf$sample), ]

grade_levels <- c("Normal", "Grade1", "Grade2", "Grade3")
metadata_train$grade <- factor(metadata_train$grade, levels = grade_levels)
metadata_test$grade  <- factor(metadata_test$grade,  levels = grade_levels)

levels(metadata_train$grade) <- make.names(levels(metadata_train$grade))
levels(metadata_test$grade)  <- make.names(levels(metadata_test$grade))

cat("Training set grade counts:\n")
print(table(metadata_train$grade))
cat("Test set grade counts:\n")
print(table(metadata_test$grade))

```
# Applying SMOTE to Balance Tumor Grade Classes
```{r echo=FALSE, message=FALSE, warning=FALSE}
library(smotefamily)

# Transpose so samples are rows
expr_t <- t(expr_train)
expr_df <- as.data.frame(expr_t)
expr_df$grade <- metadata_train$grade[match(rownames(expr_df), metadata_train$sample)]

# Convert grade to factor
expr_df$grade <- as.factor(expr_df$grade)

# Apply SMOTE (over-sampling only)
# dup_size controls how many synthetic samples to make per minority sample
smote_result <- SMOTE(X = expr_df[, -ncol(expr_df)],
                      target = expr_df$grade,
                      K = 1,
                      dup_size = 5)  # try 5–10

# SMOTE returns a list with $data
expr_smote <- smote_result$data

# Extract new metadata and expression matrix
metadata_train <- data.frame(
  sample = paste0("SMOTE_", seq_len(nrow(expr_smote))),
  grade = expr_smote$class
)

expr_balanced <- t(as.matrix(expr_smote[, -ncol(expr_smote)]))
colnames(expr_balanced) <- metadata_train$sample

metadata_train$grade <- factor(
  expr_smote$class,
  levels = c("Normal", "Grade1", "Grade2", "Grade3")
)

table(metadata_train$grade)

```

# Feature Selection and Top N Genes (ascending p-value)
```{r}
# Feature Selection on SMOTE-balanced Data
labels_factor <- factor(metadata_train$grade, levels = c("Normal", "Grade1", "Grade2", "Grade3"))
design <- model.matrix(~ 0 + labels_factor)
colnames(design) <- levels(labels_factor)

fit <- lmFit(expr_balanced, design)
fit <- eBayes(fit)
res <- topTable(fit, number = Inf, adjust.method = "BH")

# Significant genes (adjusted p < 0.05)
sig_genes <- rownames(subset(res, adj.P.Val < 0.05))

# Sort by adjusted p-value
res_sig_strong <- res[sig_genes, ]
res_sig_strong <- res_sig_strong[order(res_sig_strong$adj.P.Val), ]

# Build top gene sets only if enough genes exist
top_gene_sets <- list()
if (nrow(res_sig_strong) >= 30)  top_gene_sets$top30  <- rownames(res_sig_strong)[1:30]
if (nrow(res_sig_strong) >= 50)  top_gene_sets$top50  <- rownames(res_sig_strong)[1:50]
if (nrow(res_sig_strong) >= 80)  top_gene_sets$top80  <- rownames(res_sig_strong)[1:80]
if (nrow(res_sig_strong) >= 110) top_gene_sets$top110 <- rownames(res_sig_strong)[1:110]

# Optional: show available gene set sizes
cat("Available gene sets:\n")
print(names(top_gene_sets))
```
# SVM KNN RF (different TOP Genes and different K-fold cv)
```{r}
library(caret)
library(ggplot2)
library(tidyr)

set.seed(123)
results <- list()
cv_folds <- 5  

y_train <- as.factor(metadata_train$grade)
levels(y_train) <- make.names(levels(y_train))
y_test <- make.names(metadata_test$grade)

acc_list <- list()        
summary_list <- list()     

for (gene_set_name in names(top_gene_sets)) {
  
  gene_set <- top_gene_sets[[gene_set_name]]
  x_train <- t(expr_balanced[gene_set, , drop = FALSE])
  x_test  <- t(expr_test[gene_set, , drop = FALSE])
  
  trctrl <- trainControl(
    method = "cv",
    number = cv_folds,
    classProbs = TRUE,
    savePredictions = "final"
  )
  
  # Model training
  svm_mod <- train(x = x_train, y = y_train, method = "svmLinear", trControl = trctrl, tuneGrid = data.frame(C = 1))
  knn_mod <- train(x = x_train, y = y_train, method = "knn", trControl = trctrl, tuneGrid = expand.grid(k = 5:10))
  rf_mod  <- train(x = x_train, y = y_train, method = "rf",  trControl = trctrl, ntree = 100)
  
  # ---------- 1. Save the cross-validation results ----------
  acc_list[[length(acc_list) + 1]] <- data.frame(GeneSet = gene_set_name, Model = "SVM", Accuracy = svm_mod$resample$Accuracy)
  acc_list[[length(acc_list) + 1]] <- data.frame(GeneSet = gene_set_name, Model = "KNN", Accuracy = knn_mod$resample$Accuracy)
  acc_list[[length(acc_list) + 1]] <- data.frame(GeneSet = gene_set_name, Model = "RF",  Accuracy = rf_mod$resample$Accuracy)
  
  # ---------- 2. Test set evaluation ----------
  test_preds <- list(
    SVM = predict(svm_mod, x_test),
    KNN = predict(knn_mod, x_test),
    RF  = predict(rf_mod,  x_test)
  )
  
  for (model_name in names(test_preds)) {
    pred <- factor(test_preds[[model_name]], levels = unique(y_test))
    truth <- factor(y_test, levels = unique(y_test))
    cm <- confusionMatrix(pred, truth)
    
    acc <- cm$overall["Accuracy"]
    kappa <- cm$overall["Kappa"]
    macro_f1 <- mean(cm$byClass[, "F1"], na.rm = TRUE)
    
    summary_list[[length(summary_list) + 1]] <- data.frame(
      GeneSet = gene_set_name,
      Model = model_name,
      Accuracy = round(acc, 4),
      MacroF1 = round(macro_f1, 4),
      Kappa = round(kappa, 4)
    )
    
    cat("\n======", gene_set_name, "-", model_name, "======\n")
    print(cm$table)
    cat("Test Accuracy:", round(acc, 3), "| Kappa:", round(kappa, 3), "| Macro F1:", round(macro_f1, 3), "\n")
  }
}

acc_df <- do.call(rbind, acc_list)
summary_df <- do.call(rbind, summary_list)
desired_order <- c("top30", "top50", "top80", "top110")
acc_df$GeneSet <- factor(acc_df$GeneSet, levels = desired_order)
summary_df$GeneSet <- factor(summary_df$GeneSet, levels = desired_order)

# -------- Plot the CV accuracy boxplot --------
ggplot(acc_df, aes(x = GeneSet, y = Accuracy, fill = Model)) +
  geom_boxplot(position = position_dodge(0.8), outlier.shape = NA) +
  geom_jitter(position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.8), size = 1, alpha = 0.6) +
  labs(
    title = "Model Accuracy (Linear selection)",
    x = "Top Gene Set",
    y = "Cross-validated Accuracy"
  ) +
  theme_minimal(base_size = 13) +
  theme(legend.position = "top")

# -------- Plot the Test evaluation metric bar chart --------
eval_long <- pivot_longer(summary_df, cols = c("Accuracy", "MacroF1", "Kappa"),
                          names_to = "Metric", values_to = "Value")

ggplot(eval_long, aes(x = GeneSet, y = Value, fill = Model)) +
  geom_col(position = position_dodge(0.8)) +
  facet_wrap(~ Metric, scales = "free_y") +
  geom_text(
    aes(label = sprintf("%.2f", Value)),
    position = position_dodge(width = 0.8),
    vjust = -0.5,
    size = 1.6
  ) +
  labs(
    title = "Test Set Evaluation(Linear): Accuracy, Macro F1, Kappa",
    x = "Top Gene Set",
    y = "Metric"
  ) +
  theme_minimal(base_size = 13) +
  theme(legend.position = "top")

```
## Nonlinear feature selection: ANOVA + paired t-test
```{r}
group <- metadata_train$grade
expr <- expr_balanced  # rows = genes, cols = samples

anova_pvals <- apply(expr, 1, function(gene_expr) {
  fit <- aov(gene_expr ~ group)
  summary(fit)[[1]][["Pr(>F)"]][1]
})

# Preserve the genes with ANOVA p < 0.05
sig_anova_genes <- names(anova_pvals[anova_pvals < 0.05])

# Paired t-test function
get_pairwise_t <- function(expr, group) {
  pairs <- combn(unique(group), 2, simplify = FALSE)
  pvals <- matrix(NA, nrow = length(sig_anova_genes), ncol = length(pairs),
                  dimnames = list(sig_anova_genes, sapply(pairs, function(p) paste(p, collapse = "_vs_"))))
  
  for (i in seq_along(pairs)) {
    p <- pairs[[i]]
    g1 <- p[1]
    g2 <- p[2]
    
    pvals[, i] <- sapply(sig_anova_genes, function(gene) {
      x1 <- expr[gene, group == g1]
      x2 <- expr[gene, group == g2]
      if (length(x1) > 1 && length(x2) > 1) {
        t.test(x1, x2)$p.value
      } else {
        NA
      }
    })
  }
  
  pvals
}

pairwise_pvals <- get_pairwise_t(expr, group)

# Select the genes with p < 0.05 in any pairwise t
sig_genes_final <- rownames(pairwise_pvals)[apply(pairwise_pvals, 1, function(x) any(x < 0.05, na.rm = TRUE))]

final_pval_order <- anova_pvals[sig_genes_final]
sig_genes_sorted <- names(sort(final_pval_order))

top_gene_sets_nonliner <- list()
if (length(sig_genes_sorted) >= 30)  top_gene_sets_nonliner$top30  <- sig_genes_sorted[1:30]
if (length(sig_genes_sorted) >= 50)  top_gene_sets_nonliner$top50  <- sig_genes_sorted[1:50]
if (length(sig_genes_sorted) >= 80)  top_gene_sets_nonliner$top80  <- sig_genes_sorted[1:80]
if (length(sig_genes_sorted) >= 110) top_gene_sets_nonliner$top110 <- sig_genes_sorted[1:110]

cat("Available gene sets (ANOVA + t-test based):\n")
print(names(top_gene_sets_nonliner))

```

```{r}
library(caret)
library(ggplot2)
library(tidyr)

set.seed(123)
results <- list()
cv_folds <- 5  

y_train <- as.factor(metadata_train$grade)
levels(y_train) <- make.names(levels(y_train))
y_test <- make.names(metadata_test$grade)

acc_list <- list()        
summary_list <- list()     

for (gene_set_name in names(top_gene_sets_nonliner)) {
  
  gene_set <- top_gene_sets_nonliner[[gene_set_name]]
  x_train <- t(expr_balanced[gene_set, , drop = FALSE])
  x_test  <- t(expr_test[gene_set, , drop = FALSE])
  
  trctrl <- trainControl(
    method = "cv",
    number = cv_folds,
    classProbs = TRUE,
    savePredictions = "final"
  )
  
  # Model training
  svm_mod <- train(x = x_train, y = y_train, method = "svmLinear", trControl = trctrl, tuneGrid = data.frame(C = 1))
  knn_mod <- train(x = x_train, y = y_train, method = "knn", trControl = trctrl, tuneGrid = expand.grid(k = 5:10))
  rf_mod  <- train(x = x_train, y = y_train, method = "rf",  trControl = trctrl, ntree = 100)
  
  # ---------- 1. Save the cross-validation results ----------
  acc_list[[length(acc_list) + 1]] <- data.frame(GeneSet = gene_set_name, Model = "SVM", Accuracy = svm_mod$resample$Accuracy)
  acc_list[[length(acc_list) + 1]] <- data.frame(GeneSet = gene_set_name, Model = "KNN", Accuracy = knn_mod$resample$Accuracy)
  acc_list[[length(acc_list) + 1]] <- data.frame(GeneSet = gene_set_name, Model = "RF",  Accuracy = rf_mod$resample$Accuracy)
  
  # ---------- 2. Test set evaluation ----------
  test_preds <- list(
    SVM = predict(svm_mod, x_test),
    KNN = predict(knn_mod, x_test),
    RF  = predict(rf_mod,  x_test)
  )
  
  for (model_name in names(test_preds)) {
    pred <- factor(test_preds[[model_name]], levels = unique(y_test))
    truth <- factor(y_test, levels = unique(y_test))
    cm <- confusionMatrix(pred, truth)
    
    acc <- cm$overall["Accuracy"]
    kappa <- cm$overall["Kappa"]
    macro_f1 <- mean(cm$byClass[, "F1"], na.rm = TRUE)
    
    summary_list[[length(summary_list) + 1]] <- data.frame(
      GeneSet = gene_set_name,
      Model = model_name,
      Accuracy = round(acc, 4),
      MacroF1 = round(macro_f1, 4),
      Kappa = round(kappa, 4)
    )
    
    cat("\n======", gene_set_name, "-", model_name, "======\n")
    print(cm$table)
    cat("Test Accuracy:", round(acc, 3), "| Kappa:", round(kappa, 3), "| Macro F1:", round(macro_f1, 3), "\n")
  }
}

acc_df <- do.call(rbind, acc_list)
summary_df <- do.call(rbind, summary_list)
desired_order <- c("top30", "top50", "top80", "top110")
acc_df$GeneSet <- factor(acc_df$GeneSet, levels = desired_order)
summary_df$GeneSet <- factor(summary_df$GeneSet, levels = desired_order)

# -------- Plot the CV accuracy boxplot --------
ggplot(acc_df, aes(x = GeneSet, y = Accuracy, fill = Model)) +
  geom_boxplot(position = position_dodge(0.8), outlier.shape = NA) +
  geom_jitter(position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.8), size = 1, alpha = 0.6) +
  labs(
    title = "Model Accuracy (Non-Linear selection)",
    x = "Top Gene Set",
    y = "Cross-validated Accuracy"
  ) +
  theme_minimal(base_size = 13) +
  theme(legend.position = "top")

# -------- Plot the Test evaluation metric bar chart --------
eval_long <- pivot_longer(summary_df, cols = c("Accuracy", "MacroF1", "Kappa"),
                          names_to = "Metric", values_to = "Value")

ggplot(eval_long, aes(x = GeneSet, y = Value, fill = Model)) +
  geom_col(position = position_dodge(0.8)) +
  geom_text(
    aes(label = sprintf("%.2f", Value)),
    position = position_dodge(width = 0.8),
    vjust = -0.5,
    size = 1.6
  ) +
  facet_wrap(~ Metric, scales = "free_y") +
  labs(
    title = "Test Set Evaluation (Nonlinear): Accuracy, Macro F1, Kappa",
    x = "Top Gene Set",
    y = "Metric"
  ) +
  theme_minimal(base_size = 13) +
  theme(legend.position = "top") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.1)))

```