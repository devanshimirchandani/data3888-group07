---
title: "COMBINED V2"
output: html_document
date: "2025-05-06"
---

```{r include=FALSE}
library(GEOquery) 
library(R.utils)
library(reshape2)
library(ggplot2)
library(limma)
library(dplyr)
library(Biobase)
library(dplyr)
library(caret)
library(e1071)  # for SVM
library(randomForest)
library(edgeR)
library(sva)
```

```{r include=FALSE}
gse <- getGEO("GSE10810")
gse10810 <- gse[[1]]

gse <- getGEO("GSE17907")
gse17907 <- gse[[1]]

gse <- getGEO("GSE15852")
gse15852  <- gse[[1]]
```

```{r}
# Function to extract and standardize grade into correct names
standardize_grade <- function(grades, pattern, replacements, remove_na = TRUE) {
  grades <- tolower(grades)
  for (i in seq_along(pattern)) {
    grades <- gsub(pattern[i], replacements[i], grades)
  }
  grades <- gsub(".*(\\b[0-3]\\b).*", "\\1", grades)  # Extract grade number if embedded
  grades[!grades %in% c("0", "1", "2", "3")] <- NA     # Drop anything unexpected
  if (remove_na) {
    grades <- as.numeric(grades)
  }
  
  # Map grades to full names
  grade_names <- c("0" = "Normal", "1" = "Grade1", "2" = "Grade2", "3" = "Grade3")
  grades <- grade_names[as.character(grades)]  # Map numbers to grade names
  
  return(grades)
}

### GSE10810
pdata10810 <- pData(gse10810)
grades10810 <- pdata10810$characteristics_ch1.3
# Patterns to handle: "grade: 0", "grade: i", "grade: ii", "grade: iii"
pdata10810$grade <- standardize_grade(
  grades10810,
  c("grade: 0", "grade: i\\b", "grade: ii\\b", "grade: iii\\b"),
  c("0", "1", "2", "3")
)
pdata10810 <- pdata10810[!is.na(pdata10810$grade), ]

### GSE17907
pdata17907 <- pData(gse17907)
grades17907 <- pdata17907$`grade sbr:ch1`
pdata17907$grade <- standardize_grade(
  grades17907,
  c("--"),
  c("0")
)
pdata17907 <- pdata17907[!is.na(pdata17907$grade), ]

### GSE15852
pdata15852 <- pData(gse15852)
grades15852 <- pdata15852$`characteristics_ch1.2`
pdata15852$grade <- standardize_grade(
  grades15852,
  c("grade: normal", "grade: grade 1", "grade: grade 2", "grade: grade 3"),
  c("0", "1", "2", "3")
)
pdata15852 <- pdata15852[!is.na(pdata15852$grade), ]

```

# visualisation of standardizing grades for module 2
```{r}
library(ggplot2)
library(dplyr)
library(ggalluvial)

# Build a mapping data frame from all datasets
build_mapping_df <- function(original_labels, dataset_name, pattern, replacements) {
  cleaned <- standardize_grade(original_labels, pattern, replacements, remove_na = FALSE)
  data.frame(
    Original = original_labels,
    Cleaned = cleaned,
    Dataset = dataset_name,
    stringsAsFactors = FALSE
  )
}

map_10810 <- build_mapping_df(
  grades10810, "GSE10810",
  c("grade: 0", "grade: i\\b", "grade: ii\\b", "grade: iii\\b"),
  c("0", "1", "2", "3")
)

map_17907 <- build_mapping_df(
  grades17907, "GSE17907",
  c("--"),
  c("0")
)


# Combine
all_maps <- bind_rows(map_10810, map_17907) %>%
  filter(!is.na(Cleaned))

# Plot
ggplot(all_maps, aes(x = Original, fill = Cleaned)) +
  geom_bar() +
  facet_wrap(~ Dataset, scales = "free_x") +
  scale_fill_manual(values = c(
    "Normal" = "#F8766D", "Grade1" = "#B79F00", "Grade2" = "#00BA38", "Grade3" = "#619CFF"
  )) +
  labs(title = "Mapping of Original Grade Labels to Standardized Names",
       x = "Original Label", y = "Frequency", fill = "Standardized Grade") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))




all_maps_long <- all_maps %>% count(Original, Cleaned) %>% filter(!is.na(Cleaned))

ggplot(all_maps_long,
       aes(axis1 = Original, axis2 = Cleaned, y = n)) +
  geom_alluvium(aes(fill = Cleaned), width = 1/12) +
  geom_stratum(width = 1/12, fill = "grey80", color = "black") +
  geom_label(stat = "stratum", aes(label = after_stat(stratum))) +
  scale_fill_manual(values = c(
    "Normal" = "#F8766D", "Grade1" = "#B79F00", "Grade2" = "#00BA38", "Grade3" = "#619CFF"
  )) +
  labs(title = "Standardizing Grade Labels Across Datasets",
       x = "Standardization Step", y = "Sample Count") +
  theme_minimal()

```

```{r}
#Put the first five into the list
pdata_list <- list(
  GSE10810 = pdata10810,
  GSE17907 = pdata17907
)

required_grades <- c("Normal", "Grade1", "Grade2", "Grade3")

qualified_datasets <- names(Filter(function(pdata) {
  all(required_grades %in% pdata$grade)
}, pdata_list))

cat("Datasets containing all four grades:", paste(qualified_datasets, collapse = ", "), "\n")

```


```{r}
# Helper function to process ExpressionSet
process_eset <- function(eset, min_avg_expr = 5) {
  exprs_mat <- exprs(eset)
  
  # Filter lowly expressed genes
  keep_exprs <- rowMeans(exprs_mat) >= min_avg_expr
  exprs_mat <- exprs_mat[keep_exprs, , drop = FALSE]
  
  # Remove duplicate genes (based on rownames)
  unique_rows <- !duplicated(rownames(exprs_mat))
  exprs_mat <- exprs_mat[unique_rows, , drop = FALSE]

  # Subset the ExpressionSet to match filtered expression matrix
  eset_filtered <- eset[rownames(exprs_mat), ]
  return(eset_filtered)
}

# Apply to each dataset and keep same names
gse10810 <- process_eset(gse10810)
gse17907 <- process_eset(gse17907)
gse15852 <- process_eset(gse15852)

```


```{r}
# 1. Expression sets
expr_list <- list(

  gse10810 = exprs(gse10810),
  gse17907 = exprs(gse17907)
)

# 2. Phenotype sets
pdata_list <- list(
  pdata10810,
  pdata17907
)

# 3. Fix phenotype rownames using geo_accession if present
pdata_list <- lapply(pdata_list, function(p) {
  if ("geo_accession" %in% colnames(p)) {
    rownames(p) <- p$geo_accession
  }
  return(p)
})

# Reassign corrected pdata

# 1. Assign pdata
pdata10810 <- pdata_list[[1]]
pdata17907 <- pdata_list[[2]]

# 2. Create pheno_list with dataset names
pheno_list <- list(
  gse10810 = pdata10810,
  gse17907 = pdata17907
)

# 3. Extract grade list and track batch
grade_list <- Map(function(expr, pheno, batch_name) {
  sample_names <- colnames(expr)
  matched_pheno <- pheno[sample_names, , drop = FALSE]
  grades <- matched_pheno$grade
  names(grades) <- sample_names
  # Track batch
  data.frame(
    sample = sample_names,
    grade = grades,
    batch = batch_name,
    stringsAsFactors = FALSE
  )
}, expr_list, pheno_list, names(pheno_list))

# 4. Combine all grade + batch info into metadata
metadata <- do.call(rbind, grade_list)

# 5. Clean sample names to remove prefixes (e.g., "gse10810.")
metadata$sample <- sub(".*\\.", "", metadata$sample)

# 6. Combine expression matrices
expr_dfs <- lapply(expr_list, function(mat) {
  df <- as.data.frame(mat)
  df$gene <- rownames(mat)
  df
})

merged_expr <- Reduce(function(x, y) full_join(x, y, by = "gene"), expr_dfs)
rownames(merged_expr) <- merged_expr$gene
merged_expr$gene <- NULL

# 7. Ensure metadata matches expression matrix columns
colnames(merged_expr) <- sub(".*\\.", "", colnames(merged_expr))  # Match cleaned sample names
metadata <- metadata[match(colnames(merged_expr), metadata$sample), ]

# 8. Final check
stopifnot(all(metadata$sample == colnames(merged_expr)))

# âœ… Outputs
metadata
```

# Visualisation of combination process for module 2
```{r}
library(ggplot2)
library(cowplot)

# 1. Original plot: Sample counts by batch and grade
plot_by_batch <- ggplot(metadata, aes(x = batch, fill = grade)) +
  geom_bar(position = "dodge") +
  labs(title = "Sample Counts by Dataset (Batch) and Grade",
       x = "Dataset (Batch)", y = "Number of Samples", fill = "Grade") +
  theme_minimal() +
  scale_fill_manual(values = c(
    "Normal" = "#F8766D", "Grade1" = "#B79F00", "Grade2" = "#00BA38", "Grade3" = "#619CFF"
  ))

# 2. Combined dataset grade distribution plot (ignoring batches)
plot_combined <- ggplot(metadata, aes(x = grade, fill = grade)) +
  geom_bar() +
  labs(title = "Combined Dataset Grade Distribution",
       x = "Grade", y = "Number of Samples", fill = "Grade") +
  theme_minimal() +
  scale_fill_manual(values = c(
    "Normal" = "#F8766D", "Grade1" = "#B79F00", "Grade2" = "#00BA38", "Grade3" = "#619CFF"
  ))

plot_by_batch
plot_combined

```
```{r}

before_genes <- nrow(merged_expr) + sum(!complete.cases(merged_expr))

# Number of genes after filtering
after_genes <- nrow(merged_expr)
metadata <- metadata[!is.na(metadata$grade), ]
metadata
# ðŸ§¼ Remove corresponding columns from merged_expr
merged_expr <- merged_expr[, metadata$sample]
anyNA(merged_expr)
sum(is.na(merged_expr))
merged_expr <- merged_expr[complete.cases(merged_expr), ]
merged_expr

table(metadata$grade)

# Number of genes before filtering
ggplot(metadata, aes(x = grade, fill = grade)) +
  geom_bar() +
  labs(title = "Combined Dataset Grade Distribution",
       x = "Grade", y = "Number of Samples", fill = "Grade") +
  theme_minimal() +
  scale_fill_manual(values = c(
    "Normal" = "#F8766D", "Grade1" = "#B79F00", "Grade2" = "#00BA38", "Grade3" = "#619CFF"
  ))


gene_counts <- data.frame(
  Status = c("Before Removing NA Genes", "After Removing NA Genes"),
  Count = c(before_genes, after_genes)
)

ggplot(gene_counts, aes(x = Status, y = Count, fill = Status)) +
  geom_bar(stat = "identity") +
  labs(title = "Gene Counts Before and After Removing Genes with Missing Values",
       y = "Number of Genes", x = "") +
  theme_minimal() +
  scale_fill_manual(values = c("Before Removing NA Genes" = "#619CFF", "After Removing NA Genes" = "#00BA38")) +
  geom_text(aes(label = Count), vjust = -0.5)



```
# CODE FOR removing low expressed genes and Visualisation for mod 2
```{r}
library(edgeR)
library(ggplot2)
library(reshape2)
library(magrittr)
library(cowplot)
library(dplyr)

dge <- DGEList(counts = merged_expr)
## A common guideline is to filter so that we retain genes expressed at least 1 cpm in the smallest group of samples
min_group_size <- min(table(metadata$grade))
keepTheseGenes <- rowSums(cpm(dge) > 1) >= min_group_size


beforeFiltering_plot <- dge %>% 
  cpm(log = TRUE) %>% 
  melt %>% 
  dplyr::filter(is.finite(value)) %>% 
  ggplot(aes(x = value, colour = Var2)) +
  geom_density() + 
  guides(colour = FALSE) +
  ggtitle("A. Before filtering", subtitle = paste0(nrow(dge), " genes")) +
  labs(x = "logCPM", y = "Density")

afterFiltering_plot <- dge %>% 
  cpm(log = TRUE) %>% 
  magrittr::extract(keepTheseGenes, ) %>%
  melt %>% 
  dplyr::filter(is.finite(value)) %>% 
  ggplot(aes(x = value, colour = Var2)) +
  geom_density() + 
  guides(colour = FALSE) +
  ggtitle("B. After filtering", subtitle = paste0(sum(keepTheseGenes), " genes")) +
  labs(x = "logCPM", y = "Density")

cowplot::plot_grid(beforeFiltering_plot, afterFiltering_plot)

merged_expr_filtered <- merged_expr[keepTheseGenes, ]

metadata <- metadata[metadata$sample %in% colnames(merged_expr_filtered), ]
merged_expr_filtered <- merged_expr_filtered[, metadata$sample]
stopifnot(all(colnames(merged_expr_filtered) == metadata$sample))

```
## CODE FOR Batch effect and Visualisation of module 2
```{r}
library(sva)

# ========== 1. Input data ==========
# merged_expr_filtered: The merged expression matrix (row = gene, column = sample)
# metadata: A data frame containing sample, batch, and grade

# ========== 2. Prepare batch and grade information ==========
batch_all <- metadata$batch
grade_all <- factor(metadata$grade)
mod_all <- model.matrix(~ grade_all)

# ========== 3. Remove genes with variance of 0 ==========
remove_zero_var_genes <- function(expr, batch) {
  keep <- apply(expr, 1, function(gene) {
    all(tapply(gene, batch, function(x) var(x) > 0))
  })
  expr[keep, ]
}

expr_clean <- remove_zero_var_genes(merged_expr_filtered, batch_all)

# ========== 4. Batch effect correction ==========
expr_corrected <- ComBat(dat = expr_clean, batch = batch_all, mod = mod_all)
library(ggplot2)
library(ggfortify)
library(RColorBrewer)
library(patchwork)

# Define a pastel pink color palette (or create your own)
pastel_pinks <- c("#FBB1BD", "#FDC8D1", "#FDDDE5", "#FFE5ED", "#F8AFA6", "#E8C7CD")

# Perform PCA
pca_before <- prcomp(t(expr_clean), scale. = TRUE)
pca_after  <- prcomp(t(expr_corrected), scale. = TRUE)

# Extract PCA data
pca_df_before <- data.frame(pca_before$x[, 1:2], metadata)
pca_df_after  <- data.frame(pca_after$x[, 1:2], metadata)

# Define a custom pink/purple palette
batch_levels <- unique(metadata$batch)
color_palette <- c("#E8C7Cd", "#FBB1BD", "#E786D7", "#B07AA1", "#D36EAF", "#C77CFF")
colors <- setNames(color_palette[seq_along(batch_levels)], batch_levels)

# Base plot function
plot_pca <- function(df, title) {
  ggplot(df, aes(x = PC1, y = PC2, color = batch)) +
    geom_point(size = 1.5) +
    stat_ellipse(type = "norm", geom = "path", linewidth = 1) +  # Only border, no fill
    scale_color_manual(values = colors) +
    labs(title = title, color = "Batch") +
    theme_minimal() +
    theme(legend.position = "bottom")
}

# Generate plots
p1 <- plot_pca(pca_df_before, "Before Batch Correction")
p2 <- plot_pca(pca_df_after, "After Batch Correction")

# Display side by side

p1 + p2

```
## split train and test
```{r}
set.seed(123)
split_by_grade <- split(metadata, metadata$grade)

train_samples <- unlist(lapply(split_by_grade, function(df) {
  n <- nrow(df)
  if (n >= 2) {
    sample(df$sample, size = floor(0.8 * n))  
  } else {
    sample(df$sample, size = 1)  
  }
}))

test_samples <- setdiff(metadata$sample, train_samples)

# ========== 6. Extract the expression matrix and metadata ==========
expr_train <- expr_corrected[, train_samples]
expr_test  <- expr_corrected[, test_samples]

metadata_train <- metadata[match(train_samples, metadata$sample), ]
metadata_test  <- metadata[match(test_samples, metadata$sample), ]

metadata_train$grade <- factor(metadata_train$grade,
                               levels = c("Normal", "Grade1", "Grade2", "Grade3"))
metadata_test$grade <- factor(metadata_test$grade,
                              levels = c("Normal", "Grade1", "Grade2", "Grade3"))

levels(metadata_train$grade) <- make.names(levels(metadata_train$grade))
levels(metadata_test$grade)  <- make.names(levels(metadata_test$grade))


cat("Training set grade counts:\n")
print(table(metadata_train$grade))
cat("Test set grade counts:\n")
print(table(metadata_test$grade))
```

# smote for training data
```{r}
library(smotefamily)

# Transpose so samples are rows
expr_t <- t(expr_train)
expr_df <- as.data.frame(expr_t)
expr_df$grade <- metadata_train$grade[match(rownames(expr_df), metadata_train$sample)]

# Convert grade to factor
expr_df$grade <- as.factor(expr_df$grade)

# Apply SMOTE (over-sampling only)
# dup_size controls how many synthetic samples to make per minority sample
smote_result <- SMOTE(X = expr_df[, -ncol(expr_df)],
                      target = expr_df$grade,
                      K = 3,
                      dup_size = 5)  # try 5â€“10

# SMOTE returns a list with $data
expr_smote <- smote_result$data

# Extract new metadata and expression matrix
metadata_train <- data.frame(
  sample = paste0("SMOTE_", seq_len(nrow(expr_smote))),
  grade = expr_smote$class
)

expr_balanced <- t(as.matrix(expr_smote[, -ncol(expr_smote)]))
colnames(expr_balanced) <- metadata_train$sample

metadata_train$grade <- factor(
  expr_smote$class,
  levels = c("Normal", "Grade1", "Grade2", "Grade3")
)

table(metadata_train$grade)
```
# CODE FOR RESAMPLING VISUALISATIONS FOR MODULE 2!!!
```{r}
library(ggplot2)
library(ggplot2)
library(uwot)

grade_levels <- c("Normal", "Grade1", "Grade2", "Grade3")
grade_palette <- c(
  "Normal" = "#F8766D",  # bright coral pink
  "Grade1" = "#B79F00",  # gold-brown
  "Grade2" = "#00BA38",  # vivid green
  "Grade3" = "#619CFF"   # sky blue
)

before <- data.frame(grade = expr_df$grade, source = "Original")
after <- data.frame(grade = expr_smote$class, source = "SMOTE")
combined <- rbind(before, after)

# Ensure factor levels for consistent color ordering
combined$grade <- factor(combined$grade, levels = grade_levels)

ggplot(combined, aes(x = grade, fill = source)) +
  geom_bar(position = "dodge") +
  scale_fill_manual(values = c("Original" = "#E8C7Cd", "SMOTE" = "#FBB1BD")) +
  scale_x_discrete(drop = FALSE) +
  labs(title = "Class Distribution Before and After SMOTE",
       x = "Grade", y = "Count") +
  theme_minimal()
# Combine original and synthetic
expr_combined <- rbind(expr_df[, -ncol(expr_df)], expr_smote[, -ncol(expr_smote)])
labels <- c(rep("Original", nrow(expr_df)), rep("SMOTE", nrow(expr_smote)))
grades <- c(as.character(expr_df$grade), as.character(expr_smote$class))

# PCA
pca <- prcomp(expr_combined, scale. = TRUE)
pca_df <- data.frame(pca$x[, 1:2], Source = labels, Grade = grades)

# Ensure consistent factor levels
pca_df$Grade <- factor(pca_df$Grade, levels = grade_levels)

ggplot(pca_df, aes(x = PC1, y = PC2, color = Grade, shape = Source)) +
  geom_point(alpha = 0.7) +
  scale_color_manual(values = grade_palette) +
  labs(title = "PCA: Real vs SMOTE Samples", color = "Grade") +
  theme_minimal()

```



# Feature Selection and Top N Genes (ascending p-value)
```{r}
# Feature Selection on SMOTE-balanced Data
labels_factor <- factor(metadata_train$grade, levels = c("Normal", "Grade1", "Grade2", "Grade3"))
design <- model.matrix(~ 0 + labels_factor)
colnames(design) <- levels(labels_factor)

fit <- lmFit(expr_balanced, design)
fit <- eBayes(fit)
res <- topTable(fit, number = Inf, adjust.method = "BH")

# Significant genes (adjusted p < 0.05)
sig_genes <- rownames(subset(res, adj.P.Val < 0.05))

# Group means and strong difference filtering (max - min > 1)
group_means <- sapply(levels(labels_factor), function(lv) {
  rowMeans(expr_balanced[, metadata_train$grade == lv, drop = FALSE])
})
expr_diff <- apply(group_means, 1, function(x) max(x) - min(x))
sig_genes_strong <- sig_genes[expr_diff[sig_genes] > 1]

# Sort by adjusted p-value
res_sig_strong <- res[sig_genes_strong, ]
res_sig_strong <- res_sig_strong[order(res_sig_strong$adj.P.Val), ]

# Build top gene sets only if enough genes exist
top_gene_sets <- list()
if (nrow(res_sig_strong) >= 30)  top_gene_sets$top30  <- rownames(res_sig_strong)[1:30]
if (nrow(res_sig_strong) >= 50)  top_gene_sets$top50  <- rownames(res_sig_strong)[1:50]
if (nrow(res_sig_strong) >= 80)  top_gene_sets$top80  <- rownames(res_sig_strong)[1:80]
if (nrow(res_sig_strong) >= 110) top_gene_sets$top110 <- rownames(res_sig_strong)[1:110]

# Optional: show available gene set sizes
cat("Available gene sets:\n")
print(names(top_gene_sets))

```
# SVM KNN RF (different TOP Genes and different K-fold cv)
```{r}
library(caret)
library(ggplot2)
library(tidyr)

set.seed(123)
results <- list()
cv_folds <- 5  

y_train <- as.factor(metadata_train$grade)
levels(y_train) <- make.names(levels(y_train))
y_test <- make.names(metadata_test$grade)

acc_list <- list()        
summary_list <- list()     

for (gene_set_name in names(top_gene_sets)) {
  
  gene_set <- top_gene_sets[[gene_set_name]]
  x_train <- t(expr_balanced[gene_set, , drop = FALSE])
  x_test  <- t(expr_test[gene_set, , drop = FALSE])
  
  trctrl <- trainControl(
    method = "cv",
    number = cv_folds,
    classProbs = TRUE,
    savePredictions = "final"
  )
  
  # Model training
  svm_mod <- train(x = x_train, y = y_train, method = "svmLinear", trControl = trctrl, tuneGrid = data.frame(C = 1))
  knn_mod <- train(x = x_train, y = y_train, method = "knn", trControl = trctrl, tuneGrid = expand.grid(k = 5:10))
  rf_mod  <- train(x = x_train, y = y_train, method = "rf",  trControl = trctrl, ntree = 100)
  
  # ---------- 1. Save the cross-validation results ----------
  acc_list[[length(acc_list) + 1]] <- data.frame(GeneSet = gene_set_name, Model = "SVM", Accuracy = svm_mod$resample$Accuracy)
  acc_list[[length(acc_list) + 1]] <- data.frame(GeneSet = gene_set_name, Model = "KNN", Accuracy = knn_mod$resample$Accuracy)
  acc_list[[length(acc_list) + 1]] <- data.frame(GeneSet = gene_set_name, Model = "RF",  Accuracy = rf_mod$resample$Accuracy)
  
  # ---------- 2. Test set evaluation ----------
  test_preds <- list(
    SVM = predict(svm_mod, x_test),
    KNN = predict(knn_mod, x_test),
    RF  = predict(rf_mod,  x_test)
  )
  
  for (model_name in names(test_preds)) {
    pred <- factor(test_preds[[model_name]], levels = unique(y_test))
    truth <- factor(y_test, levels = unique(y_test))
    cm <- confusionMatrix(pred, truth)
    
    acc <- cm$overall["Accuracy"]
    kappa <- cm$overall["Kappa"]
    macro_f1 <- mean(cm$byClass[, "F1"], na.rm = TRUE)
    
    summary_list[[length(summary_list) + 1]] <- data.frame(
      GeneSet = gene_set_name,
      Model = model_name,
      Accuracy = round(acc, 4),
      MacroF1 = round(macro_f1, 4),
      Kappa = round(kappa, 4)
    )
    
    cat("\n======", gene_set_name, "-", model_name, "======\n")
    print(cm$table)
    cat("Test Accuracy:", round(acc, 3), "| Kappa:", round(kappa, 3), "| Macro F1:", round(macro_f1, 3), "\n")
  }
}

acc_df <- do.call(rbind, acc_list)
summary_df <- do.call(rbind, summary_list)
desired_order <- c("top30", "top50", "top80", "top110")
acc_df$GeneSet <- factor(acc_df$GeneSet, levels = desired_order)
summary_df$GeneSet <- factor(summary_df$GeneSet, levels = desired_order)

# -------- Plot the CV accuracy boxplot --------
ggplot(acc_df, aes(x = GeneSet, y = Accuracy, fill = Model)) +
  geom_boxplot(position = position_dodge(0.8), outlier.shape = NA) +
  geom_jitter(position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.8), size = 1, alpha = 0.6) +
  labs(
    title = "Model Accuracy (Linear selection)",
    x = "Top Gene Set",
    y = "Cross-validated Accuracy"
  ) +
  theme_minimal(base_size = 13) +
  theme(legend.position = "top")

# -------- Plot the Test evaluation metric bar chart --------
eval_long <- pivot_longer(summary_df, cols = c("Accuracy", "MacroF1", "Kappa"),
                          names_to = "Metric", values_to = "Value")

ggplot(eval_long, aes(x = GeneSet, y = Value, fill = Model)) +
  geom_col(position = position_dodge(0.8)) +
  facet_wrap(~ Metric, scales = "free_y") +
  labs(
    title = "Test Set Evaluation: Accuracy, Macro F1, Kappa",
    x = "Top Gene Set",
    y = "Metric"
  ) +
  theme_minimal(base_size = 13) +
  theme(legend.position = "top")

```

## Nonlinear feature selection: ANOVA + paired t-test
```{r}
group <- metadata_train$grade
expr <- expr_balanced  # rows = genes, cols = samples

anova_pvals <- apply(expr, 1, function(gene_expr) {
  fit <- aov(gene_expr ~ group)
  summary(fit)[[1]][["Pr(>F)"]][1]
})

# Preserve the genes with ANOVA p < 0.05
sig_anova_genes <- names(anova_pvals[anova_pvals < 0.05])

# Paired t-test function
get_pairwise_t <- function(expr, group) {
  pairs <- combn(unique(group), 2, simplify = FALSE)
  pvals <- matrix(NA, nrow = length(sig_anova_genes), ncol = length(pairs),
                  dimnames = list(sig_anova_genes, sapply(pairs, function(p) paste(p, collapse = "_vs_"))))
  
  for (i in seq_along(pairs)) {
    p <- pairs[[i]]
    g1 <- p[1]
    g2 <- p[2]
    
    pvals[, i] <- sapply(sig_anova_genes, function(gene) {
      x1 <- expr[gene, group == g1]
      x2 <- expr[gene, group == g2]
      if (length(x1) > 1 && length(x2) > 1) {
        t.test(x1, x2)$p.value
      } else {
        NA
      }
    })
  }
  
  pvals
}

pairwise_pvals <- get_pairwise_t(expr, group)

# Select the genes with p < 0.05 in any pairwise t
sig_genes_final <- rownames(pairwise_pvals)[apply(pairwise_pvals, 1, function(x) any(x < 0.05, na.rm = TRUE))]

final_pval_order <- anova_pvals[sig_genes_final]
sig_genes_sorted <- names(sort(final_pval_order))

top_gene_sets_nonliner <- list()
if (length(sig_genes_sorted) >= 30)  top_gene_sets_nonliner$top30  <- sig_genes_sorted[1:30]
if (length(sig_genes_sorted) >= 50)  top_gene_sets_nonliner$top50  <- sig_genes_sorted[1:50]
if (length(sig_genes_sorted) >= 80)  top_gene_sets_nonliner$top80  <- sig_genes_sorted[1:80]
if (length(sig_genes_sorted) >= 110) top_gene_sets_nonliner$top110 <- sig_genes_sorted[1:110]

cat("Available gene sets (ANOVA + t-test based):\n")
print(names(top_gene_sets_nonliner))

```

```{r}
library(caret)
library(ggplot2)
library(tidyr)

set.seed(123)
results <- list()
cv_folds <- 5  

y_train <- as.factor(metadata_train$grade)
levels(y_train) <- make.names(levels(y_train))
y_test <- make.names(metadata_test$grade)

acc_list <- list()        
summary_list <- list()     

for (gene_set_name in names(top_gene_sets_nonliner)) {
  
  gene_set <- top_gene_sets_nonliner[[gene_set_name]]
  x_train <- t(expr_balanced[gene_set, , drop = FALSE])
  x_test  <- t(expr_test[gene_set, , drop = FALSE])
  
  trctrl <- trainControl(
    method = "cv",
    number = cv_folds,
    classProbs = TRUE,
    savePredictions = "final"
  )
  
  # Model training
  svm_mod <- train(x = x_train, y = y_train, method = "svmLinear", trControl = trctrl, tuneGrid = data.frame(C = 1))
  knn_mod <- train(x = x_train, y = y_train, method = "knn", trControl = trctrl, tuneGrid = expand.grid(k = 5:10))
  rf_mod  <- train(x = x_train, y = y_train, method = "rf",  trControl = trctrl, ntree = 100)
  
  # ---------- 1. Save the cross-validation results ----------
  acc_list[[length(acc_list) + 1]] <- data.frame(GeneSet = gene_set_name, Model = "SVM", Accuracy = svm_mod$resample$Accuracy)
  acc_list[[length(acc_list) + 1]] <- data.frame(GeneSet = gene_set_name, Model = "KNN", Accuracy = knn_mod$resample$Accuracy)
  acc_list[[length(acc_list) + 1]] <- data.frame(GeneSet = gene_set_name, Model = "RF",  Accuracy = rf_mod$resample$Accuracy)
  
  # ---------- 2. Test set evaluation ----------
  test_preds <- list(
    SVM = predict(svm_mod, x_test),
    KNN = predict(knn_mod, x_test),
    RF  = predict(rf_mod,  x_test)
  )
  
  for (model_name in names(test_preds)) {
    pred <- factor(test_preds[[model_name]], levels = unique(y_test))
    truth <- factor(y_test, levels = unique(y_test))
    cm <- confusionMatrix(pred, truth)
    
    acc <- cm$overall["Accuracy"]
    kappa <- cm$overall["Kappa"]
    macro_f1 <- mean(cm$byClass[, "F1"], na.rm = TRUE)
    
    summary_list[[length(summary_list) + 1]] <- data.frame(
      GeneSet = gene_set_name,
      Model = model_name,
      Accuracy = round(acc, 4),
      MacroF1 = round(macro_f1, 4),
      Kappa = round(kappa, 4)
    )
    
    cat("\n======", gene_set_name, "-", model_name, "======\n")
    print(cm$table)
    cat("Test Accuracy:", round(acc, 3), "| Kappa:", round(kappa, 3), "| Macro F1:", round(macro_f1, 3), "\n")
  }
}

acc_df <- do.call(rbind, acc_list)
summary_df <- do.call(rbind, summary_list)
desired_order <- c("top30", "top50", "top80", "top110")
acc_df$GeneSet <- factor(acc_df$GeneSet, levels = desired_order)
summary_df$GeneSet <- factor(summary_df$GeneSet, levels = desired_order)

# -------- Plot the CV accuracy boxplot --------
ggplot(acc_df, aes(x = GeneSet, y = Accuracy, fill = Model)) +
  geom_boxplot(position = position_dodge(0.8), outlier.shape = NA) +
  geom_jitter(position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.8), size = 1, alpha = 0.6) +
  labs(
    title = "Model Accuracy (Non-Linear selection)",
    x = "Top Gene Set",
    y = "Cross-validated Accuracy"
  ) +
  theme_minimal(base_size = 13) +
  theme(legend.position = "top")

# -------- Plot the Test evaluation metric bar chart --------
eval_long <- pivot_longer(summary_df, cols = c("Accuracy", "MacroF1", "Kappa"),
                          names_to = "Metric", values_to = "Value")

ggplot(eval_long, aes(x = GeneSet, y = Value, fill = Model)) +
  geom_col(position = position_dodge(0.8)) +
  facet_wrap(~ Metric, scales = "free_y") +
  labs(
    title = "Test Set Evaluation: Accuracy, Macro F1, Kappa",
    x = "Top Gene Set",
    y = "Metric"
  ) +
  theme_minimal(base_size = 13) +
  theme(legend.position = "top")
```

